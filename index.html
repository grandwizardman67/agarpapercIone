<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>AgarPaper.io</title>


<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="AgarPaper.io is a great alternative to Agar.io. Control a square or a large map, gather energy, grow and eat other players to become the biggest one of all!">
<meta name="keywords" content="agarpaper.io">
<meta property="og:url" content="agarpaper.io">
<meta property="og:type" content="website">
<meta property="og:title" content="Play AgarPaper.io with me!">
<meta property="og:description" content="Play as a square set out to become the biggest square on the server. Eat the squares of other players and get bigger, bigger, EVEN BIGGER, no one can stop you!">
<meta property="og:image" content="http://agarpaper.io/images/agarpaper_share.jpg">
<meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">

<link href="./AgarPaper.io_files/css" rel="stylesheet" type="text/css">
<link href="./AgarPaper.io_files/css(1)" rel="stylesheet" type="text/css">
<link href="./AgarPaper.io_files/css(2)" rel="stylesheet" type="text/css">
<link href="./AgarPaper.io_files/css(3)" rel="stylesheet">
<link href="./AgarPaper.io_files/style.css" rel="stylesheet">
<link rel="shortcut icon" href="http://agarpaper.io/favicon.png">
<script async="" type="text/javascript" src="./AgarPaper.io_files/gpt.js"></script><script async="" type="text/javascript" src="./AgarPaper.io_files/prebid-idhb-v3.22.min.js"></script><script type="text/javascript" async="" src="./AgarPaper.io_files/analytics.js"></script><script src="./AgarPaper.io_files/sdk.js" async="" crossorigin="anonymous"></script><script async="" src="./AgarPaper.io_files/gamedock-sdk.min.js"></script><script async="" src="./AgarPaper.io_files/tag.js"></script><script id="facebook-jssdk" src="./AgarPaper.io_files/sdk.js(1)"></script><script id="twitter-wjs" src="./AgarPaper.io_files/widgets.js"></script><script id="gdsdk" type="text/javascript" async="" src="./AgarPaper.io_files/main.min.js"></script><script src="./AgarPaper.io_files/jquery.js"></script><style></style>
<script>
var userprotocol = "";
var nick = null;
var donid = 0;
var donpas = '';
var playercolor = 0; 
</script>
<style>
	body{padding:0;margin:0;overflow-x:hidden;}
	#canvas{margin-left:0;position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;}
</style>
<script type="text/javascript" async="" src="./AgarPaper.io_files/analytics.js" id="gdsdk_google_analytics"></script><script charset="utf-8" src="./AgarPaper.io_files/button.1378e6a69a23712ca26755ee3c4084b4.js"></script><script type="text/javascript" async="" src="./AgarPaper.io_files/gameDistributionV1.3.min.js" id="gdsdk_prebid"></script><script type="text/javascript" async="" src="./AgarPaper.io_files/ima3_debug.js" id="gdsdk_ima"></script><style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_dialog_advanced{border-radius:8px;padding:10px}.fb_dialog_content{background:#fff;color:#373737}.fb_dialog_close_icon{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{left:5px;right:auto;top:5px}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent}.fb_dialog_close_icon:active{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #365899;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{height:100%;left:0;margin:0;overflow:visible;position:absolute;top:-10000px;transform:none;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{background:none;height:auto;min-height:initial;min-width:initial;width:auto}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{clear:both;color:#fff;display:block;font-size:18px;padding-top:20px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .4);bottom:0;left:0;min-height:100%;position:absolute;right:0;top:0;width:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_mobile .fb_dialog_iframe{position:sticky;top:0}.fb_dialog_content .dialog_header{background:linear-gradient(from(#738aba), to(#2c4987));border-bottom:1px solid;border-color:#043b87;box-shadow:white 0 1px 1px -1px inset;color:#fff;font:bold 14px Helvetica, sans-serif;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:linear-gradient(from(#4267B2), to(#2a4887));background-clip:padding-box;border:1px solid #29487d;border-radius:3px;display:inline-block;line-height:18px;margin-top:3px;max-width:85px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{background:none;border:none;color:#fff;font:bold 12px Helvetica, sans-serif;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #4a4a4a;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f5f6f7;border:1px solid #4a4a4a;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://static.xx.fbcdn.net/rsrc.php/v3/yD/r/t-wz8gw1xG1.png);background-position:50% 50%;background-repeat:no-repeat;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}</style></head>
<body>
	<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="./AgarPaper.io_files/js"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-92276269-5');
</script>

   
    <script src="./AgarPaper.io_files/afg.js"></script>

	<canvas id="canvas" width="1315" height="920"></canvas>
	<script>
		window.game_mode = 'agar_classic';
	ï»¿function startGame(name) { 
	nick  = name;
	if (!name) {
		nick = null;
	}
	connn('149.202.86.204:766');
}


function autoclean() {
	if (!hasOverlay) { 
		window.fixDeadHalf();
	}
}
setInterval(autoclean,5000);




var shars = null;
var stats = null;



var _cloop = 0; 
var cachedFoodPos = []; 
for(var o=0; o<720; o+=2) {
	cachedFoodPos[o] = Math.cos((o*Math.PI)/180)*10;
	cachedFoodPos[o+1] = Math.sin((o*Math.PI)/180)*10;
} 




function createCookie(name,value,days) {
	if (days) {
		var date = new Date();
		date.setTime(date.getTime()+(days*24*60*60*1000));
		var expires = "; expires="+date.toGMTString();
	}
	else var expires = "";
	document.cookie = name+"="+value+expires+"; path=/";
}

function readCookie(name) {
	var nameEQ = name + "=";
	var ca = document.cookie.split(';');
	for(var i=0;i < ca.length;i++) {
		var c = ca[i];
		while (c.charAt(0)==' ') c = c.substring(1,c.length);
		if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
	}
	return null;
}

function eraseCookie(name) {
	createCookie(name,"",-1);
}

function htmlspecialchars(html) {
      html = html.replace(/&/g, "&amp;");
      html = html.replace(/</g, "&lt;");
      html = html.replace(/>/g, "&gt;");
      html = html.replace(/"/g, "&quot;");
      return html;
}







function secondsToHms(d) {
    d = Number(d);
    var h = Math.floor(d / 3600);
    var m = Math.floor(d % 3600 / 60);
    var s = Math.floor(d % 3600 % 60);
    return ((h > 0 ? h + ":" + (m < 10 ? "0" : "") : "") + m + ":" + (s < 10 ? "0" : "") + s);
}

OnGameStart = function(cells) {
    shars = cells;
    ResetStats();
}


function ResetStats() {
    stats = {
        pellets: {num:0, mass:0},
        w: {num:0, mass:0},
        cells: {num:0, mass:0},
        viruses: {num:0, mass:0},

        birthday: Date.now(),
        time_of_death: null,
        high_score: 0,
        top_slot: Number.POSITIVE_INFINITY,

        gains: {},
        losses: {},
    };
}


OnUpdateMass = function(mass) {
    stats.high_score = Math.max(stats.high_score, mass);
}

OnLeaderboard = function(position) {
    stats.top_slot = Math.min(stats.top_slot, position);
}




function DrawStats(game_over) {
	if (game_over){
	        stats.time_of_death = Date.now();
	}
	var time = stats.time_of_death ? stats.time_of_death : Date.now();
	var seconds = ~~((time - stats.birthday)/1000);

	if ((seconds <= 3) && (game_over)) { startGame(); }
	var topscore = ~~(stats.high_score/100);


	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	// this is the place where you die

	// you must open endgame overlay here

	// game stats are the following: 

	doShowOverlay(seconds, stats.top_slot, topscore);

}


OnShowOverlay = function(game_in_progress) {
    DrawStats(!game_in_progress);
}






var globalFoodCache = {};



var isDisableFoodAnimation = true;
var isDisableSkinCaching = false;
//var recievedgamemode = 0;
var hasOverlay = true;
var playerGroup = [];
var isTargeting = false;

var socketaddr = '';
var targetBufferX = 0;
var targetBufferY = 0;
var mapmaxX = 0;
var mapmaxY = 0;
var freeze = false;
var settednick = '';
var chathistory = 100;
var spectclick = false;
var isSpectating = false;
var seq = '';
var myprevnick = '';









(function(win, $) {

var tbOnRUDxsz = [];

var socketStateNew = 0;
var myx = 0;
var myy = 0;
var myla = '';
var dop = 0;
var mycolo = '';


    const DEBUG = false;
    /**
     * @param {string} total
     * @return {undefined}
     */






    function debug(total) {
        if (DEBUG) {
            console.log("debug: " + Date.now() + " " + total);
        }
    }
    /**
     * @return {undefined}
     */
    function init() {
        /** @type {boolean} */
        initialized = true;
	isTyping = false;
        /** @type {(HTMLElement|null)} */
        canvas = cv = document.getElementById("canvas");
        ctx = canvas.getContext("2d");
        /**
         * @param {Event} e
         * @return {undefined}  
         */







        canvas.onfocus = function () {
            isTyping = false;
        };




        canvas.onmousedown = function(e) {
            if (isMobile) {
                /** @type {number} */
                var x0 = e.clientX - (5 + width / 5 / 2);
                /** @type {number} */
                var y0 = e.clientY - (5 + width / 5 / 2);
                if (Math.sqrt(x0 * x0 + y0 * y0) <= width / 5 / 2) {
                    updateMousePosition();
                    sendPacket(17);
                    return;
                }
            }
	 if (!isSpectating) {
            mouseX = e.clientX;
            mouseY = e.clientY;
            updateMouseAim();
            updateMousePosition();
	 }
	 if (isSpectating) {
            mouseX = e.clientX;
            mouseY = e.clientY;
	    spectclick = true;
            updateMouseAim();
            updateMousePosition();
	    middleX = aimX;
	    middleY = aimY;
		if (middleX > maxX-500) { middleX = maxX-500;}
		if (middleX < 500) { middleX = 500;}
		if (middleY > maxY-500) { middleY = maxY-500;}
		if (middleY < 500) { middleY = 500;}
	 }



        };




document.documentElement.onmousemove  = function(e) {
  //      window.onmousemove = function(e) {
	 if (!isSpectating) {
            mouseX = e.clientX;
            mouseY = e.clientY;
            updateMouseAim();
	 }
        	if (!isSpectating) {
        	    if (0.8 > zoom) { zoom = 0.8; }
        	    if (zoom > 4 / ratio) { zoom = 4 / ratio; }
        };

}




        /**
         * @return {undefined}
         */
        canvas.onmouseup = function() {};
        if (/firefox/i.test(navigator.userAgent)) {
            document.addEventListener("DOMMouseScroll", onDocumentMouseScroll, false);
        } else {
            /** @type {function (Event): undefined} */
            document.body.onmousewheel = onDocumentMouseScroll;
        }
        /** @type {boolean} */
        var keySpacePressed = false;
        /** @type {boolean} */
        /** @type {boolean} */
        var keyWPressed = false;
        /**
         * @param {?} e
         * @return {undefined}
         */
        win.onkeydown = function(e) {
            if (!(32 != e.keyCode)) {
                if ((!keySpacePressed) && (!isTyping)) {
                    updateMousePosition();
                    sendPacket(17);
                    /** @type {boolean} */
                    keySpacePressed = true;
                }
            }
            if (!(87 != e.keyCode)) {
                if ((!keyWPressed) && (!isTyping) && (!freeze)) {
                    updateMousePosition();
                    sendPacket(21);
                    /** @type {boolean} */ 
                    keyWPressed = true;
                }
            }




        };
        /**
         * @param {?} event
         * @return {undefined}
         */
        win.onkeyup = function(event) {
            if (32 == event.keyCode) {
                /** @type {boolean} */
                keySpacePressed = false;
            }

            if (87 == event.keyCode) {
                /** @type {boolean} */
                keyWPressed = false;
            }

        };
        /**
         * @return {undefined}
         */
        win.onblur = function() {
            keyWPressed = keySpacePressed = false;
        };
        /** @type {function (): undefined} */
        window.onresize = onResize;
        onResize();
        if (win.requestAnimationFrame) {
            win.requestAnimationFrame(tick);
        } else {
            setInterval(draw, 1E3 / 60);
        }
        setInterval(updateMousePosition, 100);

    }
    /**
     * @param {Event} event
     * @return {undefined}
     */
    function onDocumentMouseScroll(event) {

        zoom *= Math.pow(0.9, event.wheelDelta / -120 || (event.detail || 0));
        if (!isSpectating) {


            if (0.8 > zoom) {
        	        zoom = 0.8;
	            }
		
            if (zoom > 4 / ratio) {
                zoom = 4 / ratio;
            }

       }

        if (isSpectating) { 
            if (0.1 > zoom) {
                zoom = 0.1;
            }
            if (zoom > 3 / ratio) {
                zoom = 3 / ratio;
            }
       }

    
    }
    /**
     * @return {undefined}
     */
    function update() {
        if (0.4 > ratio) {
            /** @type {null} */
            context = null;
        } else {
            /** @type {number} */
            var minX = Number.POSITIVE_INFINITY;
            /** @type {number} */
            var minY = Number.POSITIVE_INFINITY;
            /** @type {number} */
            var maxX = Number.NEGATIVE_INFINITY;
            /** @type {number} */
            var maxY = Number.NEGATIVE_INFINITY;
            /** @type {number} */
            var maxSize = 0;
            /** @type {number} */
            var i = 0;
            for (; i < list.length; i++) {
                var data = list[i];
                if (!!data.shouldRender()) {
                    if (!data.wasSimpleDrawing) {
                        if (!(20 >= data.size * ratio)) {
                            /** @type {number} */
                            maxSize = Math.max(data.size, maxSize);
                            /** @type {number} */
                            minX = Math.min(data.x, minX);
                            /** @type {number} */
                            minY = Math.min(data.y, minY);
                            /** @type {number} */
                            maxX = Math.max(data.x, maxX);
                            /** @type {number} */
                            maxY = Math.max(data.y, maxY);
                        }
                    }
                }
            }
            context = path.init({
                minX: minX - (maxSize + 100),
                minY: minY - (maxSize + 100),
                maxX: maxX + (maxSize + 100),
                maxY: maxY + (maxSize + 100),
                maxChildren: 2,
                maxDepth: 4
            });
            /** @type {number} */
            i = 0;
            for (; i < list.length; i++) {
                if (data = list[i], data.shouldRender() && !(20 >= data.size * ratio)) {
                    /** @type {number} */
                    var j = 0;
                    /** @type {number} */
                    var x = 0;
                    /** @type {number} */
                    var y = 0;
                    for (; j < data.points.length; ++j) {
                        x = data.points[j].x;
                        y = data.points[j].y;
                        if (!(x < offsetX - width / 2 / ratio)) {
                            if (!(y < offsetY - height / 2 / ratio)) {
                                if (!(x > offsetX + width / 2 / ratio)) {
                                    if (!(y > offsetY + height / 2 / ratio)) {
                                        context.insert(data.points[j]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * @return {undefined}
     */
    function updateMouseAim() {



        aimX = (mouseX - width / 2) / ratio + offsetX;
        aimY = (mouseY - height / 2) / ratio + offsetY;
    }

    /**
     * @return {undefined}
     */



    /**
     * @param {boolean} isAlive
     * @return {undefined}
     */
    function showOverlays(isAlive) {
        OnShowOverlay(isAlive);
    }



    function open(url,command) {
socketaddr = url;
seq = command;
        if (socket) {
            /** @type {null} */
            socket.onopen = null;
            /** @type {null} */
            socket.onmessage = null;
            /** @type {null} */
            socket.onclose = null;
            try {
                socket.close();
            } catch (b) {}
            /** @type {null} */
            socket = null;
        }



        /** @type {Array} */
        ids = [];
        /** @type {Array} */
        tbOnRUDxsz = [];
        blobs = {};
        /** @type {Array} */
        list = [];
        /** @type {Array} */
        sprites = [];
        /** @type {Array} */
        users = [];
        /** @type {null} */
        img = angles = null;
        /** @type {number} */
        score = 0;
        $("#server_ip").val(url.substr(5)); //XXX
        console.log("Connecting to server at " + url);
        /** @type {WebSocket} */
        socket = new WebSocket(url);
        /** @type {string} */
        socket.binaryType = "arraybuffer";
        /** @type {function (): undefined} */
        socket.onopen = socketOpen;
        /** @type {function (MessageEvent): undefined} */
        socket.onmessage = socketMessage;
        /** @type {function (): undefined} */
        socket.onclose = socketClose;
        /**
         * @return {undefined}
         */
        socket.onerror = function() {
            console.log("Socket error");
        };
    }
    /**
     * @param {number} bytes
     * @return {?}
     */
    function createBuffer(bytes) {
        return new DataView(new ArrayBuffer(bytes));
    }
    /**
     * @param {?} array
     * @return {undefined}
     */
    function socketWrite(array) {
        	socket.send(array.buffer);
    }
    /**
     * @return {undefined}
     */
function socketOpen() {
        /** @type {number} */
        backoff = 500;
	socketStateNew = 1;
        console.log("Socket open");
	//performing primary authentication
        var buffer = createBuffer(5);
        buffer.setUint8(0, 254);
        buffer.setUint32(1, 111, true);
        socketWrite(buffer);
        buffer = createBuffer(5);
        buffer.setUint8(0, 255);
        buffer.setUint32(1, 1111, true);
        socketWrite(buffer);
	//sending client version
        buffer = createBuffer(2);
        buffer.setUint8(0, 253);
        buffer.setUint8(1, 2, true);
        socketWrite(buffer);
	// sending client version done
	//performing primary authentication done
	// now let's perform the appropriate initial spawn/spectate sequences
//	console.log('command: ', seq);
	if (seq == 'spawn') {
		doFirstSpawn();
	}
	if (seq == 'spectate') {
		doFirstSpectate();
	}



}


    /**
     * @return {undefined}
     */
    function socketClose() {
	socketStateNew = 0;
	socketaddr = '';
	window.currentStatus = null;
        console.log("Socket close");
    }
    /**
     * @param {MessageEvent} a
     * @return {undefined}
     */
    function socketMessage(a) {
        parse(new DataView(a.data));
    }
    /**
     * @param {DataView} reader
     * @return {undefined}
     */
    function parse(reader) {
        /**
         * @return {?}
         */
        function encode() {
            /** @type {string} */
            var str = "";
            for (;;) {
                var b = reader.getUint16(offset, true);
                offset += 2;
                if (0 == b) {
                    break;
                }
                str += String.fromCharCode(b);
            }
            return str;
        }
        /** @type {number} */
        var offset = 0;
        if (240 == reader.getUint8(offset)) {
            offset += 5;
        }

//console.log(reader.getUint8(offset));

        switch (reader.getUint8(offset++)) {
            case 16:
		if (serverProtocol > 10) {
                 qweR(reader, offset);
		}
                break;
            case 17:
                middleX = reader.getFloat32(offset, true);
                offset += 4;
                middleY = reader.getFloat32(offset, true);
                offset += 4;
                chunk = reader.getFloat32(offset, true);
                offset += 4;
                break;
            case 20:
                tbOnRUDxsz = [];
                ids = [];
                break;
            case 21:
                targetX = reader.getInt16(offset, true);
                offset += 2;
                targetY = reader.getInt16(offset, true);
                offset += 2;
                break;
            case 32:
                offset += 4;
                break;
            case 49:
                if (null != angles) {
                    break;
                }
                var b = reader.getUint32(offset, true);
                offset = offset + 4;
                /** @type {Array} */
                users = [];
                /** @type {number} */
                var a = 0;
                for (; a < b; ++a) {
                    var token = reader.getUint32(offset, true);
                    offset = offset + 4;
                    users.push({
                        id: token,
                        name: encode()
                    });
                }
                render();
                break;
            case 50:
                /** @type {Array} */
                angles = [];
                b = reader.getUint32(offset, true);
                offset += 4;
                /** @type {number} */
                a = 0;
                for (; a < b; ++a) {
                    angles.push(reader.getFloat32(offset, true));
                    offset += 4;
                }
                render();
                break;

            case 64:
                minX = reader.getFloat64(offset, true);
                offset += 8;
                minY = reader.getFloat64(offset, true);
                offset += 8;
                maxX = reader.getFloat64(offset, true);
                offset += 8;
                maxY = reader.getFloat64(offset, true);
                offset += 8;

		mapmaxX = maxX;
		mapmaxY = maxY;

                /** @type {number} */
                middleX = (maxX + minX) / 2;
                /** @type {number} */
                middleY = (maxY + minY) / 2;
                /** @type {number} */
                chunk = 1;
                if (0 == tbOnRUDxsz.length) {
                    /** @type {number} */
                    offsetX = middleX;
                    /** @type {number} */
                    offsetY = middleY;
                    /** @type {number} */
                    ratio = chunk;
                }
		break;

            case 78:
                wrongpass = reader.getUint8(offset, true);
                offset += 1;
		console.log('78 Wrong server password');
		break;


            case 88:
                reason = reader.getUint8(offset, true);
                offset += 1;
		console.log('88 Kick');
		break;


            case 89:
                reason = reader.getUint8(offset, true);
                offset += 1;
		console.log('89 Local ban');
		break;

            case 90:
                uptime = reader.getFloat64(offset, true);
                offset += 8;
		uptime = (~~(uptime / 60) + 1);
		jQuery("#uptime").html("uptime: " + uptime + " minutes");
                onlinestat = reader.getFloat64(offset, true);
                offset += 8;
		jQuery("#onlinestat").html(onlinestat);
		break;

            case 91:
                reason = reader.getUint8(offset, true);
                offset += 1;
		console.log('91 Full ban');
		break;

            case 92:
                connlimit = reader.getUint8(offset, true);
                offset += 1;
		console.log('92 too many conns');
		break;

            case 93:
                slotslimit = reader.getUint8(offset, true);
                offset += 1;
		console.log('93 No slots');
		break;

            case 94:
                nickslimit = reader.getUint8(offset, true);
                offset += 1;
		console.log('94 Too many nicks');
		break;

            case 95:
                gotospec = reader.getUint8(offset, true);
                offset += 1;
                break;

            case 96:
                recievedgamemode = reader.getUint8(offset, true);
                offset += 1;
		//console.log(recievedgamemode);
                break;

            case 97:
                request = reader.getUint8(offset, true);
                offset += 1;
		console.log('request yes');
                break;


            case 98:
                serverProtocol = reader.getUint8(offset, true);
                offset += 1;
                break;

            case 99:
//                addChat(reader, offset);
                break;

            case 100:
                var high = reader.getFloat64(offset, true);
//		console.log(high);
//		jQuery("#yourhigh").html(" Your server high: " + high + " mass");
		break;

            case 101:
                var gotospecarena = reader.getUint8(offset, true);
		console.log("101 " + gotospecarena);
                break;


			

            case 102:
                request = reader.getUint8(offset, true);
                offset += 1;
		console.log('lite request yes');
		setTimeout(function(){window.sp(2);}, 100);
                break;


            case 103:
                level = reader.getUint8(offset, true);
                offset += 1;
                break;

            case 104:
                offset += 1;
                break;

            case 105:
//                addChatPrivate(reader, offset);
                break;


            case 200:
                break;

        }
    }












    /**
     * @param {DataView} reader
     * @param {number} offset
     * @return {undefined}
     */
    function qweR(reader, offset) {
	//ids = [];
        /** @type {number} */
        timestampLastDraw = +new Date;
        /** @type {number} */
        var rand = Math.random();
        /** @type {boolean} */
        qweA = false;
        var qweS = reader.getUint16(offset, true);
        offset += 2;
        /** @type {number} */
        var i = 0;
        for (; i < qweS; ++i) {
            var blob1 = blobs[reader.getUint32(offset, true)];
            var blob2 = blobs[reader.getUint32(offset + 4, true)];
            offset += 8;
            if (blob1) {
                if (blob2) {

                    blob2.destroy();
                    blob2.ox = blob2.x;
                    blob2.oy = blob2.y;
                    blob2.oSize = blob2.size;
                    blob2.nx = blob1.x;
                    blob2.ny = blob1.y;
                    blob2.nSize = blob2.size;
                    /** @type {number} */
                    blob2.updateTime = timestampLastDraw;
                }
            }



        }



        /** @type {number} */
        i = 0;
        for (;;) {
            var id = reader.getUint32(offset, true);
            offset += 4;
            if (0 == id) {
                break;
            }
            ++i;
	    var cellType = -1;
	if (serverProtocol >= 17) {
	    cellType = reader.getUint8(offset, true);
	    offset += 1;
	}

	if (serverProtocol <= 15) {
            var x = reader.getInt16(offset, true);
            offset += 2;
            var y = reader.getInt16(offset, true);
            offset += 2;
	}

	if (serverProtocol >= 16) {
            var x = reader.getInt32(offset, true);
            offset += 4;
            var y = reader.getInt32(offset, true);
            offset += 4;
	}

            var size = reader.getInt16(offset, true);
            offset += 2;
	    var sticker = 0;
	    var skin = 0;
	if ((serverProtocol >= 12) && (serverProtocol < 15)) {
            sticker = reader.getInt8(offset, true);
            offset += 1;
	}
	if (serverProtocol >= 15) {
            sticker = reader.getInt32(offset, true);
            offset += 4;
	}
	if (serverProtocol >= 14) {
            skin = reader.getInt32(offset, true);
            offset += 4;
	}
            var color = reader.getUint8(offset++);
            var flags = reader.getUint8(offset++);
            var isVirus = reader.getUint8(offset++);

	    if (!isVirus) {
		skin = 0;
		sticker = 0;
	    }

            /** @type {string} */
            color = (color << 16 | flags << 8 | isVirus).toString(16);
            for (; 6 > color.length;) {
                /** @type {string} */
                color = "0" + color;
            }
            /** @type {string} */
            color = "#" + color;




	    //globalFoodCache[color]++; 

            flags = reader.getUint8(offset++);
            /** @type {boolean} */
            isVirus = !!(flags & 1);
            /** @type {boolean} */
            var isAgitated = false;
            if (flags & 2) {
                offset += 4;
            }
            if (flags & 4) {
                offset += 8;
            }
            if (flags & 8) {
                offset += 16;
            }
		if (flags & 32) {
			if (ids.indexOf(id)==-1) {
				ids.push(id);
			}
		}


            var readChar;
            /** @type {string} */
            var name = "";
            for (;;) {
                readChar = reader.getUint16(offset, true);
                offset += 2;
                if (0 == readChar) {
                    break;
                }
                name += String.fromCharCode(readChar);
            }

            /** @type {null} */
            var blob = null;
            if (blobs.hasOwnProperty(id)) {
                blob = blobs[id];
                blob.updatePos();
                blob.ox = blob.x;
                blob.oy = blob.y;
                blob.oSize = blob.size;
                blob.color = color;
		blob.sticker = sticker;
		blob.skin = skin;
		blob.cellType = cellType;
		if (tbOnRUDxsz[0]) {

			mycolo = tbOnRUDxsz[0].color;
		}

            } else {
                blob = new Blob(id, x, y, size, color, name);
                list.push(blob);
                blobs[id] = blob;
                blob.pX = x;
                blob.pY = y;
		blob.sticker = sticker;
		blob.skin = skin;
		blob.cellType = cellType;
            }
            /** @type {boolean} */
            blob.isVirus = isVirus;
            /** @type {boolean} */
            blob.isAgitated = isAgitated;
            blob.nx = x;
            blob.ny = y;
            blob.nSize = size;
            /** @type {number} */
            blob.updateCode = rand;
            /** @type {number} */
            blob.updateTime = timestampLastDraw;
            blob.flags = flags;



            if (name) {
                blob.setName(name);


            }
	    var uuy = window.selmode;

            if (-1 != ids.indexOf(id)) {
                if (-1 == tbOnRUDxsz.indexOf(blob)) {
                    /** @type {string} */
                    tbOnRUDxsz.push(blob);
                    if (1 == tbOnRUDxsz.length) {
                        offsetX = blob.x;
                        offsetY = blob.y;
			score = 0;
			OnGameStart(tbOnRUDxsz);
			settednick = tbOnRUDxsz[0].name;


                    }
                }
            }
        }
        var qweT = reader.getUint32(offset, true);
        offset += 4;
        /** @type {number} */
        i = 0;
        for (; i < qweT; i++) {
            id = reader.getUint32(offset, true);
            offset += 4;
            blob = blobs[id];
            if (null != blob) {
                blob.destroy();
            }
        }
        if (qweA) {
            if (0 == tbOnRUDxsz.length) {
                showOverlays(false);
            }
        }
    }
    /**
     * @return {undefined}
     */
    function updateMousePosition() {
     if ((!isSpectating) || (isSpectating && (spectclick == true))) {
        if (isSocketOpen()) {
            /** @type {number} */
            var normalizeX = mouseX - width / 2;
            /** @type {number} */
            var normalizeY = mouseY - height / 2;
            if (!(64 > normalizeX * normalizeX + normalizeY * normalizeY)) {
                if (!(0.01 > Math.abs(aimXOld - aimX) && 0.01 > Math.abs(aimYOld - aimY))) {
                    aimXOld = aimX;
                    aimYOld = aimY;
                    var output = createBuffer(21);
                    output.setUint8(0, 16);
                    output.setFloat64(1, Math.floor(aimX), true);
                    output.setFloat64(9, Math.floor(aimY), true);
                    output.setUint32(17, 0, true);
                    socketWrite(output);
		    spectclick = false;
                }
            }
        }
      }
    }
    /**
     * @return {undefined}
     */



		win.doSendNick = doSendNick;

function doSendNick() {

	if (nick == null) {
		nick = 'PaPeR.IO::::::::::3';
	}
	else {
		nick = nick + '::::::::::3';
	}

	if (isSocketOpen() && null != nick) {

		var ret = createBuffer(1 + 2 * nick.length);
		ret.setUint8(0, 0);
		var i = 0;
		for (; i < nick.length; ++i) {
			ret.setUint16(1 + 2 * i, nick.charCodeAt(i), true);
		}
		socketWrite(ret);
        }
}

function doSendPass() {
	pass = '*';
	if (isSocketOpen() && null != pass) {
		var ret = createBuffer(1 + 2 * pass.length);
		ret.setUint8(0, 77);
		var i = 0;
		for (; i < pass.length; ++i) {
			ret.setUint16(1 + 2 * i, pass.charCodeAt(i), true);
		}
		socketWrite(ret);
	}
}


function doFirstSpawn() {
//	console.log('Spawning a player');
        setSpectate(false);
	setUnlimitedZoom(false);
	doSendNick();
        doSendPass();
	sendChat("***playerenter***");
	sendChat("***playerenter***");
	myla = '';
}


function doFirstSpectate() {
	setSpectate(true);
	setUnlimitedZoom(true);
        doSpectate();
        doSendPass();
	myla = '';

}








    function sendNick() {

        if (isSocketOpen() && null != nick) {
		myprevnick = nick;
            var ret = createBuffer(1 + 2 * nick.length);
            ret.setUint8(0, 0);
            /** @type {number} */
            var i = 0;
            for (; i < nick.length; ++i) {
                ret.setUint16(1 + 2 * i, nick.charCodeAt(i), true);
            }
            socketWrite(ret);

        }
    }

    function sendPass() {
        if (isSocketOpen() && null != pass) {
            var ret = createBuffer(1 + 2 * pass.length);
            ret.setUint8(0, 77);
            /** @type {number} */
            var i = 0;
            for (; i < pass.length; ++i) {
                ret.setUint16(1 + 2 * i, pass.charCodeAt(i), true);
            }
            socketWrite(ret);
        }
    }

    function fixDead() {
	i = 0;
	for (; i < list.length; i++) {
	  var lag = Date.now() - list[i].updateTime;
	  if (lag>3000) {
	    blobs[list[i].id].destroy();
	  }
	}


    }


    function fixDeadHalf() {
	i = 0;
	for (; i < list.length; i++) {
	  var lag = Date.now() - list[i].updateTime;
	  if (lag>5000) {
	   if (list[i].name != '') {
	    blobs[list[i].id].destroy();
	   }
	  }
	}
	sprites = [];
    }










function connn(id,title) {

	globallastid = id;

	yesterdayloaded = 0;
	twodaysloaded = 0;

	var prefix = 5;
	if (userprotocol =='s') {prefix = 6;}
	var soccc = socketaddr.substr(prefix,socketaddr.length);
	var addrs = id.split(":");	
	var sip = addrs[0];
	var sport = parseInt(addrs[1],10);
	// connecting to some server while not connected to anything at all
	if (socketStateNew == 0)  {
		loaddate = '';
		alltimeloaddate = '';
		//console.log('we 1');
		open('ws' + userprotocol + '://' + sip + ':' + sport + '','spawn');
	}

	//reconnecting to the same server while connected
	if ((socketStateNew == 1) && (soccc == sip + ':' + sport))  {
//		console.log('we 2');
		setUnlimitedZoom(false);
		if (isSpectating) {
			setSpectate(false);
			window.sp(2);
		}
		else {
			window.sp(2);
		}
	}

	//switching the server while connected
	if ((socketStateNew == 1) && (soccc != sip + ':' + sport))  {
		//console.log('we 3');
		loaddate = '';
		alltimeloaddate = '';
		open('ws' + userprotocol + '://' + sip + ':' + sport + '','spawn');
		setTimeout(function(){setSpectate(false);setUnlimitedZoom(false);}, 100);
	}
}





function connnspec(id,title) {
	yesterdayloaded = 0;
	twodaysloaded = 0;
	var prefix = 5;
	if (userprotocol =='s') {prefix = 6;}
	var soccc = socketaddr.substr(prefix,socketaddr.length);
	if (id == null) { id = globallastid; }
	var addrs = id.split(":");	
	var sip = addrs[0];
	var sport = parseInt(addrs[1],10);
	if (id == null) { id = soccc;}	
	if (socketStateNew == 0)  {
		//console.log('wes 1');
		loaddate = '';
		alltimeloaddate = '';
		open('ws' + userprotocol + '://' + sip + ':' + sport + '','spectate');
	}

	if ((socketStateNew == 1) && (soccc == sip + ':' + sport))  {
//		console.log('wes 2',spect,window.shars);
		if (window.shars) {
 			if (window.shars.length == 0) {
 				//console.log('we 6');
				jQuery('#specbutton').show();
				setSpectate(true);
				setUnlimitedZoom(true);
				window.sp(1);

 			}
		}
		if (window.shars) {
			if (window.shars.length > 0) {
 				//console.log('we 7');
				jQuery('#specbutton').hide();
				setSpectate(false);
				setUnlimitedZoom(false);
			}
		}
	}

	if ((socketStateNew == 1) && (soccc != sip + ':' + sport))  {
//		console.log('wes 3');
		loaddate = '';
		alltimeloaddate = '';
		open('ws' + userprotocol + '://' + sip + ':' + sport + '','spectate');
	}
}








    function sendChat(str) {
	var nni = 'petridish.pw'; 
	var ismod = -1;
	var cutstr = str.substr(0,str.length-4);


	var ctime = readCookie("lastchat");
	if (ctime == '0') {
		var ctime = new Date().getTime();
	}
	var nowtime = new Date().getTime();
	var ago = nowtime - ctime;
        if (isSocketOpen() && (str.length < 200) && (str.length > 0) && ((ago > 5000) || (ismod != -1)) ) {
	 myla = str;
         var msg = createBuffer(2 + 2 * str.length);
         var offset = 0;
         msg.setUint8(offset++, 99);
         msg.setUint8(offset++, 0); // flags (0 for now)
         for (var i = 0; i < str.length; ++i) {
          msg.setUint16(offset, str.charCodeAt(i), true);
          offset += 2;
         }
         socketWrite(msg);
	 createCookie('lastchat',new Date().getTime(),999);

        }
    }





    window.sendChat = sendChat;
    window.connnspec = connnspec;
    window.connn = connn;
    window.sp = sendPacket;
    window.fixDead = fixDead;
    window.fixDeadHalf = fixDeadHalf;
    window.checksp = isSpectating;
    window.preparePattern = preparePattern;

    /**
     * @return {?}
     */
    function isSocketOpen() {
	//console.log('checking the socket state',socket,socket.readyState);
        return null != socket && socket.readyState == socket.OPEN;
    }
    /**
     * @param {number} id
     * @return {undefined}
     */
    function sendPacket(id) {
        if (isSocketOpen()) {
            var ret = createBuffer(1);
            ret.setUint8(0, id);
            socketWrite(ret);
        }
    }














    /**
     * @return {undefined}
     */
    function tick() {
        draw();
        win.requestAnimationFrame(tick);
    }
    /**
     * @return {undefined}
     */
    function onResize() {
        /** @type {number} */
        width = win.innerWidth;
        /** @type {number} */
        height = win.innerHeight;
        /** @type {number} */
        cv.width = canvas.width = width;
        /** @type {number} */
        cv.height = canvas.height = height;
        draw();
    }
    /**
     * @return {?}
     */
    function unitRatio() {
        return Math.max(height / 1080, width / 1920) * zoom;
    }
    /**
     * @return {undefined}
     */
    function updateRatio() {
        if (0 != tbOnRUDxsz.length) {
            /** @type {number} */
            var size = 0;
            /** @type {number} */
            var i = 0;
            for (; i < tbOnRUDxsz.length; i++) {
                size += tbOnRUDxsz[i].size;
            }
            /** @type {number} */
            size = Math.pow(Math.min(64 / size, 1), 0.4) * unitRatio();
            /** @type {number} */
            ratio = (9 * ratio + size) / 10;
        }
    }
    /**
     * @return {undefined}
     */
    function draw() {
        var playerHeight;
        /** @type {number} */
        var timestamp = Date.now();
        ++qweB;
        /** @type {number} */
        timestampLastDraw = timestamp;
        if (0 < tbOnRUDxsz.length) {
            updateRatio();
            /** @type {number} */
            var playerWidth = playerHeight = 0;
            /** @type {number} */
            var i = 0;
            for (; i < tbOnRUDxsz.length; i++) {
                tbOnRUDxsz[i].updatePos();
                playerHeight += tbOnRUDxsz[i].x / tbOnRUDxsz.length;
                playerWidth += tbOnRUDxsz[i].y / tbOnRUDxsz.length;
            }
            /** @type {number} */
            middleX = playerHeight;
            /** @type {number} */
            middleY = playerWidth;
            chunk = ratio;
            /** @type {number} */
            offsetX = (offsetX + playerHeight) / 2;
            /** @type {number} */
            offsetY = (offsetY + playerWidth) / 2;
        } else {
            /** @type {number} */
            offsetX = (29 * offsetX + middleX) / 30;
            /** @type {number} */
            offsetY = (29 * offsetY + middleY) / 30;
            /** @type {number} */
            ratio = (9 * ratio + chunk * unitRatio()) / 10;
        }
        update();
	if (!isSpectating) {
          updateMouseAim();
	}
        ctx.clearRect(0, 0, width, height);
	drawCell();
        list.sort(function(a, b) {
            return a.size == b.size ? a.id - b.id : a.size - b.size;
        });
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.scale(ratio, ratio);
        ctx.translate(-offsetX, -offsetY);

            drawBorders(ctx);

        /** @type {number} */
        myMass = Math.min.apply(null, tbOnRUDxsz.map(function(r) { //XXX
            return r.getMass();
        }));
        /** @type {number} */
        i = 0;


        for (; i < sprites.length; i++) {
            sprites[i].draw(ctx);
        }
        /** @type {number} */
        i = 0;
        for (; i < list.length; i++) {
            list[i].draw(ctx);
        }

        ctx.restore();
        if (img) {
            if (img.width) {
                ctx.drawImage(img, width - img.width - 10, 10);
            }
        }
        /** @type {number} */
        score = Math.max(score, getScore());
        if (0 != score) {
            if (null == button) {
                button = new SVGPlotFunction(20, "#FFFFFF");
            }
	    var bbuuX = 0;
	    var bbuuY = 0;
            button.setValue("Score: " + ~~(getScore() / 100));
            playerWidth = button.render();
            playerHeight = playerWidth.width;
            /** @type {number} */
            ctx.globalAlpha = 0.5;
            /** @type {string} */
            ctx.fillStyle = "#2a6496";
            ctx.fillRect(10, 10, playerHeight + 10, 34);
            /** @type {number} */
            ctx.globalAlpha = 1;
            ctx.drawImage(playerWidth, 15, 15);
		if ((tbOnRUDxsz) && tbOnRUDxsz[0]) {
		OnUpdateMass(getScore());
		}

        }



        /** @type {number} */
        timestamp = Date.now() - timestamp;
        if (timestamp > 1E3 / 60) {
            renderDetail -= 0.01;
        } else {
            if (timestamp < 1E3 / 65) {
                renderDetail += 0.01;
            }
        }
        if (0.4 > renderDetail) {
            /** @type {number} */
            renderDetail = 0.4;
        }
        if (1 < renderDetail) {
            /** @type {number} */
            renderDetail = 1;
        }
    }


//customgridcolor
function preparePattern(idt) {
	var canvasPattern = document.createElement("canvas");
	var rr = 2;
	window.rr = rr;
	canvasPattern.width = 104 * rr;
	canvasPattern.height = 60 * rr;
	var contextPattern = canvasPattern.getContext("2d");
	contextPattern.fillStyle = idt ? "#111111" : "#dff3f7";
	contextPattern.fillRect(0, 0, canvasPattern.width, canvasPattern.height);
	contextPattern.strokeStyle = idt ? "#AAAAAA" : "#000000";
	contextPattern.lineWidth = 5;
	contextPattern.globalAlpha = 0.2;
	contextPattern.beginPath();
	var len = 69.3 / 2;
	var cpy = 30,
	cpx = 69.3 / 2;
	for (var o = 0; o < 360; o += 60) {
		contextPattern.moveTo((cpx + Math.cos(o * Math.PI / 180) * len) * rr + 1, (cpy + Math.sin(o * Math.PI / 180) * len) * rr + 1);
		contextPattern.lineTo((cpx + Math.cos((o + 60) * Math.PI / 180) * len) * rr + 1, (cpy + Math.sin((o + 60) * Math.PI / 180) * len) * rr + 1);
	}
	contextPattern.moveTo(69.3 * rr + 1, 30 * rr + 1);
	contextPattern.lineTo(104 * rr + 1, 30 * rr + 1);
	contextPattern.stroke();

	window["bg" + (idt ? 1 : 0)] = canvasPattern;
	return rr;
}

//preparePattern(true);
//preparePattern(false);

function drawCell() {
        ctx.fillStyle = isDarkTheme ? "#111111" : "#dff3f7";



        ctx.fillRect(0, 0, width, height);

	isHideGrid = true;
	if (!isHideGrid) {
	var context = ctx;

	context.save();
	var frr = window.rr;
	var wp = 104 * frr;
	var hp = 60 * frr;
	var dr = ratio;
	var cx = offsetX + wp * 1000 - ((width / dr) / 2);
	var cy = offsetY + hp * 1000 - ((height / dr) / 2);
	var sx = (-cx % wp) * dr;
	var sy = (-cy % hp) * dr;
	context.translate(sx, sy);
	context.scale(dr, dr);

	var pattern = context.createPattern(isDarkTheme ? window.bg1 : window.bg0, "repeat");
	context.fillStyle = pattern;
	context.fillRect(0, 0, (width - sx) / dr, (height - sy) / dr);
	context.fill();
	context.restore();
	}

}






    /**
     * @return {undefined}
     */
    function drawGrid() {



        /** @type {string} */
        ctx.fillStyle = isDarkTheme ? "#111111" : "#dff3f7";

        ctx.fillRect(0, 0, width, height);

	if (!isHideGrid) {
        ctx.save();
	        /** @type {string} */
	        ctx.strokeStyle = isDarkTheme ? "#AAAAAA" : "#000000";
		if (isCustomGridc) { ctx.strokeStyle = customgridcolor; }
	        /** @type {number} */
	        ctx.globalAlpha = 0.2;
		if (isCustomGridc) { ctx.globalAlpha = 0.9; }
	        ctx.scale(ratio, ratio);
	        /** @type {number} */
	        var gridOffsetX = width / ratio;
	        /** @type {number} */
 	       var gridOffsetY = height / ratio;
 	       /** @type {number} */
	       ctx.beginPath(); // ÑÐ¸ÐºÑ1
 	       var y = -0.5 + (-offsetX + gridOffsetX / 2) % 50;
 	       for (; y < gridOffsetX; y += 50) {
	            //ctx.beginPath();
        	    ctx.moveTo(y, 0);
	            ctx.lineTo(y, gridOffsetY);
        	    //ctx.stroke();
	        }
        	/** @type {number} */
	        y = -0.5 + (-offsetY + gridOffsetY / 2) % 50;
	        for (; y < gridOffsetY; y += 50) {
	            //ctx.beginPath();
	            ctx.moveTo(0, y);
	            ctx.lineTo(gridOffsetX, y);
	            //ctx.stroke();
	        }
		ctx.stroke();//ÑÐ¸ÐºÑ2
        ctx.restore();
	}



    }

    /**
     * @return {undefined}
     */
    function drawSplitButton() {
        if (isMobile && imageSplitButton.width) {
            /** @type {number} */
            var dim = width / 5;
            ctx.drawImage(imageSplitButton, 5, 5, dim, dim);
        }
    }
    /**
     * @return {?}
     */
    function getScore() {
        /** @type {number} */
        var value = 0;
        /** @type {number} */
        var i = 0;
        for (; i < tbOnRUDxsz.length; i++) {
            value += tbOnRUDxsz[i].nSize * tbOnRUDxsz[i].nSize;
        }
        return value;
    }
    /**
     * @return {undefined}
     */
    function render() {
        /** @type {null} */
        img = null;
        if (null != angles || 0 != users.length) {
//            if (null != angles || isNames) {
            if (1 == 1) {
                /** @type {Element} */
                img = document.createElement("canvas");


                var ctx = img.getContext("2d");
                var i = 60;
                i = null == angles ? i + 24 * users.length : i + 180;

		var lbwidth = 220;
		var qweU = Math.min(lbwidth, 0.3 * width) / lbwidth;
		img.width = lbwidth * qweU;
                img.height = i * qweU;
                ctx.scale(qweU, qweU);
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = "#2a6496";
                ctx.fillRect(0, 0, lbwidth, i);
                ctx.globalAlpha = 1;
                ctx.fillStyle = "#FFFFFF";
                var qweV = "Leaderboard";
                /** @type {string} */
                ctx.font = "30px Russo One";
                ctx.fillText(qweV, lbwidth/2 - ctx.measureText(qweV).width / 2, 40);
                if (null == angles) {
                    /** @type {string} */
                    ctx.font = "20px Russo One";
                    /** @type {number} */
                    i = 0;
                    for (; i < users.length; ++i) {
                        qweV = users[i].name || "An unnamed block";

                        if (-1 != ids.indexOf(users[i].id)) {
                            if (tbOnRUDxsz[0].name) {
                            }
                            ctx.fillStyle = "#FFAAAA";
				OnLeaderboard(i + 1);
                        } else {
                            ctx.fillStyle = "#FFFFFF";
                        }

	        qweV = i + 1 + ". " + qweV;
		ctx.fillText(qweV, 5, 70 + 24 * i);
 
                }

                } else {
                    /** @type {number} */
                    var qweW = 0;
                    /** @type {number} */
                    i = 0;
                    for (; i < angles.length; ++i) {
                        /** @type {number} */
                        var qweX = qweW + angles[i] * Math.PI * 2;
                        ctx.fillStyle = qweH[i + 1];
                        ctx.beginPath();
                        ctx.moveTo(100, 140);
                        ctx.arc(100, 140, 80, qweW, qweX, false);
                        ctx.fill();
                        /** @type {number} */
                        qweW = qweX;
                    }
                }
            }
        }
    }
    /**
     * @param {Function} id
     * @param {number} x
     * @param {number} y
     * @param {number} size
     * @param {string} color
     * @param {string} name
     * @return {undefined}
     */
    function Blob(id, x, y, size, color, name) {
        /** @type {Function} */
        this.id = id;
        this.ox = this.x = x;
        this.oy = this.y = y;
        this.oSize = this.size = size;
        /** @type {string} */
        this.color = color;
        /** @type {Array} */
        this.points = [];
        /** @type {Array} */
        this.pointsAcc = [];
        this.createPoints();
        this.setName(name);
    }
    /**
     * @param {number} size
     * @param {string} color
     * @param {?} stroke
     * @param {string} strokeColor
     * @return {undefined}
     */
    function SVGPlotFunction(size, color, stroke, strokeColor) {
        if (size) {
            /** @type {number} */
            this._size = size;
        }
        if (color) {
            /** @type {string} */
            this._color = color;
        }
        /** @type {boolean} */
        this._stroke = !!stroke;
        if (strokeColor) {
            /** @type {string} */
            this._strokeColor = strokeColor;
        }
    }





    /**
     * @param {(Object|null)} ctx
     * @return {undefined}
     */
    function drawBorders(ctx) { //XXX
        if (isDarkTheme) {
            /** @type {string} */
            ctx["strokeStyle"] = "#FFFFFF";
        }
       ctx.beginPath();
	ctx.strokeStyle = "#80969e";
	ctx.lineWidth = 25;
        ctx.moveTo(0, 0); 
        ctx.lineTo(maxX, 0);
        ctx.lineTo(maxX, maxY);
        ctx.lineTo(0, maxY);
        ctx.lineTo(0, 0);
        ctx.stroke();






    }


    /** @type {string} */
    var protocol = win.location.protocol;
    /** @type {boolean} */
    var isSecure = "https:" == protocol;
    if (1 == 2) {

    } else {
        var cv;
        var ctx;
        var canvas;
        var width;
        var height;
        /** @type {null} */
        var context = null;
        /** @type {null} */
        var socket = null;
        /** @type {number} */
        var offsetX = 0;
        /** @type {number} */
        var offsetY = 0;
        /** @type {Array} */
        var ids = [];
        /** @type {Array} */
        //var tbOnRUDxsz = [];

	var chatBoard = [];

        var blobs = {};
        /** @type {Array} */
        var list = [];
        /** @type {Array} */
        var sprites = [];
        /** @type {Array} */
        var users = [];
        /** @type {number} */
        var mouseX = 0;
        /** @type {number} */
        var mouseY = 0;
        /** @type {number} */
        var aimX = -1;
        /** @type {number} */
        var aimY = -1;
        /** @type {number} */
        var qweB = 0;
        /** @type {number} */
        var timestampLastDraw = 0;
        /** @type {null} */
        // var nick = null;
        var pass = null;
        /** @type {number} */
        var minX = 0;
        /** @type {number} */
        var minY = 0;
        /** @type {number} */
        var maxX = 1E4;
        /** @type {number} */
        var maxY = 1E4;
        /** @type {number} */
        var ratio = 1;
        /** @type {null} */
        var region = null;
        /** @type {boolean} */
        var isSkins = true;
        var isStickers = true;

        /** @type {boolean} */
        var isNames = true;
	var isNamesAlways = false;
        /** @type {boolean} */
        var isColorsOff = false;
        /** @type {boolean} */
        /** @type {boolean} */
        var qweA = false;
        /** @type {number} */
        var score = 0;
        /** @type {boolean} */
        var isDarkTheme = false;
        /** @type {boolean} */
        var isShowMass = true; //XXX
        /** @type {number} */
        var middleX = offsetX = ~~((minX + maxX) / 2);
        /** @type {number} */
        var middleY = offsetY = ~~((minY + maxY) / 2);
        /** @type {number} */
        var chunk = 1;
        /** @type {string} */
        var gameMode = "";
        /** @type {null} */
        var angles = null;
        /** @type {boolean} */
        var initialized = false;
        /** @type {boolean} */
        /** @type {number} */
        var targetX = 0;
        /** @type {number} */
        var targetY = 0;
	var recievedgamemode = 0;
	var recievedgamemodeExtended = 0;
	var recievedgamemodeParams = [];
	var serverProtocol = 9;
	var ingamefocus = 1;
        /** @type {number} */
        var previousKey = 0;
        /** @type {Array} */
        var qweH = ["#333333", "#FF3333", "#33FF33", "#3333FF"];
        /** @type {boolean} */
        var isAcidMode = false;
        /** @type {number} */
        var zoom = 1;
        /** @type {boolean} */
        var isMobile = "ontouchstart" in win && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        /** @type {Image} */
        var imageSplitButton = new Image;
        /** @type {string} */
        imageSplitButton.src = "engine/split.png";
        /** @type {Element} */
        var test_canvas = document.createElement("canvas");
        if ("undefined" == typeof console || ("undefined" == typeof DataView || ("undefined" == typeof WebSocket || (null == test_canvas || (null == test_canvas.getContext || null == win.localStorage))))) {
            alert("You browser does not support this game, we recommend you to use Firefox to play this");
        } else {
            /** @type {null} */
            var regions = null;
            /**
             * @param {Function} input
             * @return {undefined}
             */




win.doSpectate = function() {
	sendPacket(1);
};







		win.sendNick = sendNick;

            win.setNick = function(input) {
                if (isSpectating) { //XXX
                    spectate();
                } else {
                    hide();
                    /** @type {Function} */
                    nick = input;
                }

            };
            win.setPass = function(input) {
                if (isSpectating) { //XXX
                    spectate();
		    pass = input;
                } else {
                    hide();
                    /** @type {Function} */
                    pass = input;
                }
                sendPass();

            };








            if (null != win.localStorage) {
                if (null == win.localStorage.AB8) {
                    /** @type {number} */
                    win.localStorage.AB8 = 0 + ~~(100 * Math.random());
                }
                /** @type {number} */
                previousKey = +win.localStorage.AB8;
                /** @type {number} */
                win.ABGroup = previousKey;
            }
            /** @type {function (string): undefined} */
            win.connect = open;
            /** @type {number} */
            var backoff = 500;
            /** @type {number} */
            var aimXOld = -1;
            /** @type {number} */
            var aimYOld = -1;
            /** @type {null} */
            var img = null;
            /** @type {number} */
            var renderDetail = 1;
            /** @type {null} */
            var button = null;
            var playersbaza = {};
            var images = {};
            var imagesAnimated = {};
            var imagesStickers = {};
            /** @type {Array.<string>} */

ï»¿isAllBorders = true;


            Blob.prototype = {
                id: 0,
		sticker: 0,
		skin: 0,
                points: null,
                pointsAcc: null,
                name: null,
                nameCache: null,
                sizeCache: null,
                x: 0,
                y: 0,
                size: 0,
                ox: 0,
                oy: 0,
                oSize: 0,
                nx: 0,
                ny: 0,
                nSize: 0,
                flags: 0,
                updateTime: 0,
                updateCode: 0,
                drawTime: 0,
                destroyed: false,
                isVirus: false,
                isAgitated: false,
                wasSimpleDrawing: true,
		isInvisibleNick: false,
		isRotatingSkin: false,
		isAnimatedSkin: false,
		isTransparentSkin: false,
                /**
                 * @return {undefined}
                 */
                destroy: function() {
                    var i;
                    /** @type {number} */
                    i = 0;
                    for (; i < list.length; i++) {
                        if (list[i] == this) {
                            list.splice(i, 1);
                            break;
                        }
                    }
                    delete blobs[this.id];
                    i = tbOnRUDxsz.indexOf(this);
                    if (-1 != i) {
                        /** @type {boolean} */
                        qweA = true;
                        tbOnRUDxsz.splice(i, 1);
                    }
                    i = ids.indexOf(this.id);
                    if (-1 != i) {
                        ids.splice(i, 1);
                    }
                    /** @type {boolean} */
                    this.destroyed = true;
                    sprites.push(this);
                },
                /**
                 * @return {?}
                 */
                getNameSize: function() {
                    if (isLargeNames) { //XXX
                        return 50 + 0.3 * this.size;
                    } else {
                        return Math.max(~~(0.3 * this.size), 24);
                    }
                },
                /**
                 * @param {string} name
                 * @return {undefined}
                 */
                setName: function(name) {

		if (name != '') {
			if ((name != this.name) || (this.name == ''))  { 
				var smallname = name.toLowerCase();
				this.isInvisibleNick = false;
				this.isRotatingSkin = false;
				this.isTransparentSkin = false;
				this.isAnimatedSkin = false;
				this.isSquareSkin = true;
				if (playersbaza[smallname]) {

					this.isInvisibleNick = playersbaza[smallname].isInvisibleNick;
					this.isRotatingSkin = playersbaza[smallname].isRotatingSkin;
					this.isTransparentSkin = playersbaza[smallname].isTransparentSkin;
					this.isAnimatedSkin = playersbaza[smallname].isAnimatedSkin;
					this.isSquareSkin = true;
				}

				if (!playersbaza[smallname]) {
					playersbaza[smallname] = [ ];
					playersbaza[smallname].isInvisibleNick = false;
					playersbaza[smallname].isSquareSkin = true;
				}
			}
		}

                    if (this.name = name) {
                        if (null == this.nameCache) {
                            this.nameCache = new SVGPlotFunction(this.getNameSize(), "#FFFFFF", true, "#000000");
                        } else {
                            this.nameCache.setSize(this.getNameSize());
                        }
                        this.nameCache.setValue(this.name);
                    }
                },
                /**
                 * @return {undefined}
                 */
                createPoints: function() {
                    var max = this.getNumPoints();
                    for (; this.points.length > max;) {
                        /** @type {number} */
                        var i = ~~(Math.random() * this.points.length);
                        this.points.splice(i, 1);
                        this.pointsAcc.splice(i, 1);
                    }
                    if (0 == this.points.length) {
                        if (0 < max) {
                            this.points.push({
                                self: this,
                                size: this.size,
                                x: this.x,
                                y: this.y
                            });
                            this.pointsAcc.push(Math.random() - 0.5);
                        }
                    }
                    var point;
                    for (; this.points.length < max;) {
                        /** @type {number} */
                        i = ~~(Math.random() * this.points.length);
                        point = this.points[i];
                        this.points.splice(i, 0, {
                            self: this,
                            size: point.size,
                            x: point.x,
                            y: point.y
                        });
                        this.pointsAcc.splice(i, 0, this.pointsAcc[i]);
                    }
                },
                /**
                 * @return {?}
                 */
                getNumPoints: function() {
                    if (0 == this.id) {
                        return 16;
                    }
                    /** @type {number} */
                    var rh = 30;
                    if (20 > this.size) {
                        /** @type {number} */
                        rh = 0;
                    }
                    if (this.isVirus) {
                        /** @type {number} */
                        rh = 30;
                    }
                    /** @type {number} */
                    var w = this.size;
                    if (!this.isVirus) {
                        w *= ratio;
                    }
                    w *= renderDetail;
                    if (this.flags & 32) {
                        w *= 0.25;
                    }
                    return ~~Math.max(w, rh);
                },
                /**
                 * @return {undefined}
                 */
                movePoints: function() {
                    this.createPoints();
                    var points = this.points;
                    var pointsAcc = this.pointsAcc;
                    var numPoints = points.length;
                    /** @type {number} */
                    var i = 0;
                    for (; i < numPoints; ++i) {
                        var qweL = pointsAcc[(i - 1 + numPoints) % numPoints];
                        var qweM = pointsAcc[(i + 1) % numPoints];
                        pointsAcc[i] += (Math.random() - 0.5) * (this.isAgitated ? 3 : 1);
                        pointsAcc[i] *= 0.7;
                        if (10 < pointsAcc[i]) {
                            /** @type {number} */
                            pointsAcc[i] = 10;
                        }
                        if (-10 > pointsAcc[i]) {
                            /** @type {number} */
                            pointsAcc[i] = -10;
                        }
                        /** @type {number} */
                        pointsAcc[i] = (qweL + qweM + 8 * pointsAcc[i]) / 10;
                    }
                    /** @type {Blob} */
                    var qweK = this;
                    /** @type {number} */
                    var qweO = 0;
                    if (!this.isVirus) {
                        /** @type {number} */
                        qweO = (this.id / 1E3 + timestampLastDraw / 1E4) % (2 * Math.PI);
                    }
                    /** @type {number} */
                    i = 0;
                    for (; i < numPoints; ++i) {
                        var size = points[i].size;
                        qweL = points[(i - 1 + numPoints) % numPoints].size;
                        qweM = points[(i + 1) % numPoints].size;
                        if (15 < this.size && (null != context && (20 < this.size * ratio && 0 != this.id))) {
                            /** @type {boolean} */
                            var qweN = false;
                            var startX = points[i].x;
                            var startY = points[i].y;
                            context.retrieve2(startX - 5, startY - 5, 10, 10, function(data) {
                                if (data.self != qweK) {
                                    if (25 > (startX - data.x) * (startX - data.x) + (startY - data.y) * (startY - data.y)) {
                                        /** @type {boolean} */
                                        qweN = true;
                                    }
                                }
                            });
                            if (!qweN) {
                                if (points[i].x < minX || (points[i].y < minY || (points[i].x > maxX || points[i].y > maxY))) {
                                    /** @type {boolean} */
                                    qweN = true;
                                }
                            }
                            if (qweN) {
                                if (0 < pointsAcc[i]) {
                                    /** @type {number} */
                                    pointsAcc[i] = 0;
                                }
                                pointsAcc[i] -= 1;
                            }
                        }
                        size += pointsAcc[i];
                        if (0 > size) {
                            /** @type {number} */
                            size = 0;
                        }
                        /** @type {number} */
                        size = this.isAgitated ? (19 * size + this.size) / 20 : (12 * size + this.size) / 13;
                        /** @type {number} */
                        points[i].size = (qweL + qweM + 8 * size) / 10;
                        /** @type {number} */
                        qweL = 2 * Math.PI / numPoints;
                        qweM = this.points[i].size;
                        if (this.isVirus) {
                            if (0 == i % 2) {
                                qweM += 5;
                            }
                        }
                        points[i].x = this.x + Math.cos(qweL * i + qweO) * qweM;
                        points[i].y = this.y + Math.sin(qweL * i + qweO) * qweM;
                    }
                },
                /**
                 * @return {?}
                 */
                updatePos: function() {
                    if (0 == this.id) {
                        return 1;
                    }
                    /** @type {number} */
                    var ratio = (timestampLastDraw - this.updateTime) / 120;
                    if (0 > ratio) {
                        /** @type {number} */
                        ratio = 0;
                    } else {
                        if (1 < ratio) {
                            /** @type {number} */
                            ratio = 1;
                        }
                    }
                    this.getNameSize();
                    if (this.destroyed && 1 <= ratio) {
                        var index = sprites.indexOf(this);
                        if (-1 != index) {
                            sprites.splice(index, 1);
                        }
                    }
                    this.x = ratio * (this.nx - this.ox) + this.ox;
                    this.y = ratio * (this.ny - this.oy) + this.oy;
                    this.size = ratio * (this.nSize - this.oSize) + this.oSize;
                    return ratio;
                },
                /**
                 * @return {?}
                 */
                shouldRender: function() {
                    if (0 == this.id) {
                        return true;
                    }
                    if (this.x + this.size + 40 < offsetX - width / 2 / ratio || (this.y + this.size + 40 < offsetY - height / 2 / ratio || (this.x - this.size - 40 > offsetX + width / 2 / ratio || this.y - this.size - 40 > offsetY + height / 2 / ratio))) {
                        return false;
                    }
                    return true;
                },
                /**
                 * @return {?}
                 */
                getMass: function() {
                    return ~~(this.size * this.size / 100);
                },
                _cachedDifference: Math.log(1.01),
                _cachedFood: {},
                /**
                 * @param {CanvasRenderingContext2D} ctx
                 * @return {undefined}
                 */
		    draw: function(ctx) {
          		isSimpleMode = true;
			var isFood = false,
			isW = false,
			x = this.x,
			y = this.y;
                    if (this.shouldRender()) {

                        if (((this.cellType == 1) || (this.cellType == 3)) && (!this.destroyed/* && this.shouldRender()*/))  {
                            var key = this.color + '_' + this.size;
                            if(this._cachedFood[key]) {//ÐµÑÐ»Ð¸ Ð² ÐºÑÑÐµ ÐµÑÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ° ÐµÐ´Ñ - Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ ÐµÐµ
				//no food animation 
				if (isDisableFoodAnimation) {
	                               ctx.drawImage(this._cachedFood[key], this.x - (this.size*3), this.y - (this.size*3));
				}
				//with food animation 
				if (!isDisableFoodAnimation) {
					if (typeof(this._cloop)=='undefined') {
						this.sp = Math.random()>0.5?1:2;
						this._ratio = (1+Math.random())*(Math.random()*2>1?1:-1); 
						//console.log('ratio = ' + this._ratio);
						this._cloop=Math.floor(Math.random()*360);
					}
					this._cloop = (this._cloop+this.sp)%360; 
					ctx.drawImage(this._cachedFood[key], this.x - (this.size*3) + (cachedFoodPos[this._cloop*2]*this._ratio), this.y - (this.size*3) + (cachedFoodPos[(this._cloop * 2)+1] * (Math.abs(this._ratio))));
				}

                                return;
                            } else {//ÐµÑÐ»Ð¸ ÐµÐ´Ñ Ð½ÐµÑÑ Ð² ÐºÑÑÐµ - Ð¿Ð¾Ð´Ð³Ð¾ÑÐ°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð¾ÑÐ´ÐµÐ»ÑÐ½ÑÐ¹ ÐºÐ¾Ð½ÑÐµÐºÑÑ
                                var newCanvas = document.createElement('canvas'),
                                    prevCtx = ctx;
				//console.log(this.x, this.y);
				//no food animation 
				if (isDisableFoodAnimation) {
	                                newCanvas.width = newCanvas.height = this.size * 6;
				}

				//with food animation 
				if (!isDisableFoodAnimation) {
	                                newCanvas.width = newCanvas.height = this.size * 6;
				}

                                ctx = newCanvas.getContext('2d');
				isFood = true;
                                x = this.size;
                                y = this.size;
                                this._cachedFood[key] = newCanvas;
				//console.log(this);
                            }
                        }

			if (this.cellType == 3) {
				isW = true;
			//	isFood = true;		
			}


			var virusshooter = false;



                        var color = this.color; //XXX
			if ((this.isVirus)) { color = "#ff9900"; }
			

                        /** @type {boolean} */
                        var isSimpleDrawing = isSimpleMode || (this.cellType == 1 && !isColorsOff) || (this.cellType == 3 && !isColorsOff); //XXX
                        if (5 > this.getNumPoints()) {
                            /** @type {boolean} */
                            isSimpleDrawing = true;
                        }
                        if (this.wasSimpleDrawing && !isSimpleDrawing) {
                            /** @type {number} */
                            var i = 0;
                            for (; i < this.points.length; i++) {
                                /** @type {number} */
                                this.points[i].size = this.size;
                            }
                        }
                        /** @type {boolean} */
                        this.wasSimpleDrawing = isSimpleDrawing;
                        ctx.save();
                        this.drawTime = timestampLastDraw;
                        var updatePos = this.updatePos();
                        if (this.destroyed) {
                            ctx.globalAlpha *= (1 - updatePos)/2;
                        }
                        /** @type {number} */
                        ctx.lineWidth = isLargeBlobBorders ? 30 : 10; //XXX

                        if (isColorsOff) {
                            /** @type {string} */
                            ctx.fillStyle = "#FFFFFF";
                            /** @type {string} */
                            ctx.strokeStyle = "#AAAAAA";
                        } else {
                            if (":teams" == gameMode && !this.isVirus) { //XXX
                                ctx.fillStyle = this.color;
                            } else {
                                ctx.fillStyle = color;
                            }
                            ctx.strokeStyle = color; //XXX
                        }

                        /** @type {string} */
                        ctx.lineCap = "round";
                        /** @type {string} */
                        ctx.lineJoin = this.isVirus ? "miter" : "round";

                        if (isVirusTransparent && this.isVirus) { //XXX
                           // ctx.globalAlpha = 0.6;
                        }
			if (isSimpleDrawing) {
				isCircleFood = true;
				ctx.beginPath();
					if (isFood) {
						ctx.rect(x+this.size,y+this.size,this.size*3,this.size*3);
					}
					else {
						var startcoordx = this.x - this.size;
						var startcoordy = this.y - this.size;
						ctx.rect(startcoordx,startcoordy,this.size*2,this.size*2);
					}
                        } else {
                            this.movePoints();
                            ctx.beginPath();
                            var numPoints = this.getNumPoints();
                            ctx.moveTo(this.points[0].x, this.points[0].y);
                            /** @type {number} */
                            i = 1;
                            for (; i <= numPoints; ++i) {
                                /** @type {number} */
                                var j = i % numPoints;
                                ctx.lineTo(this.points[j].x, this.points[j].y);
                            }
                        }
                        ctx.closePath();
			if (this.name) {
        	                var name = this.name.toLowerCase();
				var textname = this.name.toLowerCase();
			}




                        /** @type {null} */
                        var nameImg = null;

			// lets sskin for those who have many RAM


			if (this.isVirus) {
				if (!images[this.skin]) {
                               		images[this.skin] = new Image;
                               		images[this.skin].src = "engine/virus.png";
                                	if (0 != images[this.skin].width && images[this.skin].complete) {
                                    		nameImg = images[this.skin];
                                	}
				}
				if (images[this.skin]) {
					nameImg = images[this.skin];
				}
			}






                        /** @type {boolean} */

			if ((this.cellType != 1) && (this.cellType != 2)) {
				ctx.stroke();
			}


			this.transp = 0;

                        if ((isSimpleDrawing) && (this.cellType == 0)) {
				if (((this.transp == 1) && (isAlwaysShowBorders)) || (virusshooter) || (isAllBorders)) {
					if (!isCustomStrokec) {
						if (this.cellType != 1) {
						ctx.globalAlpha = 0.8;
						ctx.stroke();
						ctx.globalAlpha = 1;
						}

					}
					if (isCustomStrokec) {
						if (this.cellType != 1) {
						ctx.strokeStyle = customstrokecolor ;
						ctx.stroke();
						}
					}
				}
			}

			if (this.transp == 0) {
				if (!this.isVirus) {
					ctx.fill();
				}
			}
                        if (nameImg) {
                                ctx.save();
                                ctx.clip();
			 	ctx.drawImage(nameImg, this.x - this.size, this.y - this.size, 2 * this.size, 2 * this.size);
                                ctx.restore();
                        }

                        if (isColorsOff || 15 < this.size) {
				if ((this.cellType != 1) && (this.cellType != 2)) {

                                /** @type {string} */
                                ctx.strokeStyle = "#000000";
                                ctx.globalAlpha *= 0.1;
                                ctx.stroke();
				}

                        }
                        /** @type {number} */
                        ctx.globalAlpha = 1;


                        /** @type {number} */
                        ctx.globalAlpha = 1; //XXX
                        /** @type {boolean} */
                        var isPlayer = -1 != tbOnRUDxsz.indexOf(this);

                        /** @type {number} */
                        if (0 != this.id) {

                            isSimpleDrawing = ~~this.y;
                            if (((isNames || isPlayer) && (this.name && (this.nameCache && (null == nameImg || this.isInvisibleNick == false)))) || (isNamesAlways && this.nameCache && this.name)) {
				
				var nameonshar = this.name;

				if ((this.isInvisibleNick) && (!isNamesAlways)) { nameonshar = ' '; }

				if (isStripSpecial) { nameonshar = nameonshar.replace(/[^\u0000-~Ð-Ó¾]/g, "."); }
				if (nameonshar != ' ') {
                                	var namePlot = this.nameCache;
                                	namePlot.setValue(nameonshar);
                                	namePlot.setSize(this.getNameSize());
                                	/** @type {number} */
                                	var nameScale = Math.ceil(10 * ratio) / 10;
                                	namePlot.setScale(nameScale);
                                	var nameRender = namePlot.render();
                                	/** @type {number} */
                                	var qweY = ~~(nameRender.width / nameScale);
                                	/** @type {number} */
                                	var qweP = ~~(nameRender.height / nameScale);
					if ((nameRender.width > 0) && (nameRender.height > 0)) {
	                                	ctx.drawImage(nameRender, ~~this.x - ~~(qweY / 2), isSimpleDrawing - ~~(qweP / 2), qweY, qweP);
					}
                                	isSimpleDrawing += nameRender.height / 2 / nameScale + 4;
				}
                            }
                        }




                        if ((isShowMass) && ((this.cellType == 0) || (this.cellType == 2))) {


                                if (null == this.sizeCache) {
                                    this.sizeCache = new SVGPlotFunction(this.getNameSize() / 2, "#FFFFFF", true, "#000000");
                                }
                                var sizePlot = this.sizeCache;
                                sizePlot.setSize(this.getNameSize() / 2);
                                sizePlot.setValue(~~(this.size * this.size / 100));
                                /** @type {number} */
                                var sizeScale = Math.ceil(10 * ratio) / 10;
                                sizePlot.setScale(sizeScale);
                                var sizeRender = sizePlot.render();
                                /** @type {number} */
                                qweY = ~~(sizeRender.width / sizeScale);
                                /** @type {number} */
                                var qweQ = ~~(sizeRender.height / sizeScale);
                                ctx.drawImage(sizeRender, ~~this.x - ~~(qweY / 2), isSimpleDrawing - ~~(qweQ / 2), qweY, qweQ);
			      
                        }


			

                        ctx.restore();
                        if(key && prevCtx) {// ÐµÑÐ»Ð¸ Ð¼Ñ Ð² Ð¿ÐµÑÐ²ÑÐ¹ ÑÐ°Ð· Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°Ð»Ð¸ ÐµÐ´Ñ, ÑÐ¾ Ð¼Ñ ÐµÐµ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÑÐ²Ð°Ð»Ð¸ Ð² Ð´ÑÑÐ³Ð¾Ð¹ ÐºÐ¾Ð½ÑÐµÐºÑÑ - Ð½ÑÐ¶Ð½Ð¾ Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¸ Ð² ÑÑÐ¾Ð¼
                            prevCtx.drawImage(this._cachedFood[key], this.x - this.size*3, this.y - this.size*3);
                        }

                    }
                }
            };

ï»¿

            SVGPlotFunction.prototype = {
                _value: "",
                _color: "#000000",
                _stroke: false,
                _strokeColor: "#000000",
                _size: 16,
                _canvas: null,
                _ctx: null,
                _dirty: false,
                _scale: 1,
                /**
                 * @param {number} size
                 * @return {undefined}
                 */
                setSize: function(size) {
                    if (this._size != size) {
                        /** @type {number} */
                        this._size = size;
                        /** @type {boolean} */
                        this._dirty = true;
                    }
                },
                /**
                 * @param {?} scale
                 * @return {undefined}
                 */
                setScale: function(scale) {
                    if (this._scale != scale) {
                        this._scale = scale;
                        /** @type {boolean} */
                        this._dirty = true;
                    }
                },
                /**
                 * @param {string} color
                 * @return {undefined}
                 */
                setStrokeColor: function(color) {
                    if (this._strokeColor != color) {
                        /** @type {string} */
                        this._strokeColor = color;
                        /** @type {boolean} */
                        this._dirty = true;
                    }
                },
                /**
                 * @param {string} value
                 * @return {undefined}
                 */
                setValue: function(value) {
                    if (value != this._value) {
                        /** @type {string} */
                        this._value = value;
                        /** @type {boolean} */
                        this._dirty = true;
                    }
                },
                /**
                 * @return {?}
                 */
                render: function() {
                    if (null == this._canvas) {
                        /** @type {Element} */
                        this._canvas = document.createElement("canvas");
                        this._ctx = this._canvas.getContext("2d");
                    }
                    if (this._dirty) {
                        /** @type {boolean} */
                        this._dirty = false;
                        var canvas = this._canvas;
                        var ctx = this._ctx;
                        var caracter = this._value;
                        var scale = this._scale;
                        var size = this._size;
                        /** @type {string} */
                        var text = size + "px Russo One";
                        /** @type {string} */
                        ctx.font = text;
                        /** @type {number} */
                        var height = ~~(0.2 * size);
                        /** @type {number} */
                        canvas.width = (ctx.measureText(caracter).width + 6) * scale;
                        /** @type {number} */
                        canvas.height = (size + height) * scale;
                        /** @type {string} */
                        ctx.font = text;
                        ctx.scale(scale, scale);
                        /** @type {number} */
                        ctx.globalAlpha = 1;
                        /** @type {number} */
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = this._strokeColor;
                        ctx.fillStyle = this._color;
                        if (this._stroke) {
                            ctx.strokeText(caracter, 3, size - height / 2);
                        }
                        ctx.fillText(caracter, 3, size - height / 2);
                    }
                    return this._canvas;
                },


        getWidth: function () {
            return (ctx.measureText(this._value).width + 6);
        }

            };
            if (!Date.now) {
                /**
                 * @return {number}
                 */
                Date.now = function() {
                    return (new Date).getTime();
                };
            }
            var path = {
                /**
                 * @param {?} args
                 * @return {?}
                 */
                init: function(args) {
                    /**
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     * @param {number} depth
                     * @return {undefined}
                     */
                    function Node(x, y, w, h, depth) {
                        /** @type {number} */
                        this.x = x;
                        /** @type {number} */
                        this.y = y;
                        /** @type {number} */
                        this.w = w;
                        /** @type {number} */
                        this.h = h;
                        /** @type {number} */
                        this.depth = depth;
                        /** @type {Array} */
                        this.items = [];
                        /** @type {Array} */
                        this.nodes = [];
                    }
                    /** @type {number} */
                    var TOP_LEFT = 0;
                    /** @type {number} */
                    var TOP_RIGHT = 1;
                    /** @type {number} */
                    var BOTTOM_LEFT = 2;
                    /** @type {number} */
                    var BOTTOM_RIGHT = 3;
                    var maxChildren = args.maxChildren || 2;
                    var maxDepth = args.maxDepth || 4;
                    Node.prototype = {
                        x: 0,
                        y: 0,
                        w: 0,
                        h: 0,
                        depth: 0,
                        items: null,
                        nodes: null,
                        /**
                         * @param {Object} selector
                         * @return {?}
                         */
                        exists: function(selector) {
                            /** @type {number} */
                            var i = 0;
                            for (; i < this.items.length; ++i) {
                                var item = this.items[i];
                                if (item.x >= selector.x && (item.y >= selector.y && (item.x < selector.x + selector.w && item.y < selector.y + selector.h))) {
                                    return true;
                                }
                            }
                            if (0 != this.nodes.length) {
                                /** @type {Node} */
                                var self = this;
                                return this.findOverlappingNodes(selector, function(dir) {
                                    return self.nodes[dir].exists(selector);
                                });
                            }
                            return false;
                        },
                        /**
                         * @param {?} item
                         * @param {?} callback
                         * @return {undefined}
                         */
                        retrieve: function(item, callback) {
                            /** @type {number} */
                            var i = 0;
                            for (; i < this.items.length; ++i) {
                                callback(this.items[i]);
                            }
                            if (0 != this.nodes.length) {
                                /** @type {Node} */
                                var self = this;
                                this.findOverlappingNodes(item, function(dir) {
                                    self.nodes[dir].retrieve(item, callback);
                                });
                            }
                        },
                        /**
                         * @param {?} item
                         * @return {undefined}
                         */
                        insert: function(item) {
                            if (0 != this.nodes.length) {
                                this.nodes[this.findInsertNode(item)].insert(item);
                            } else {
                                if (this.items.length >= maxChildren && this.depth < maxDepth) {
                                    this.divide();
                                    this.nodes[this.findInsertNode(item)].insert(item);
                                } else {
                                    this.items.push(item);
                                }
                            }
                        },
                        /**
                         * @param {?} item
                         * @return {?}
                         */
                        findInsertNode: function(item) {
                            if (item.x < this.x + this.w / 2) {
                                if (item.y < this.y + this.h / 2) {
                                    return TOP_LEFT;
                                }
                                return BOTTOM_LEFT;
                            }
                            if (item.y < this.y + this.h / 2) {
                                return TOP_RIGHT;
                            }
                            return BOTTOM_RIGHT;
                        },
                        /**
                         * @param {Object} item
                         * @param {Function} callback
                         * @return {?}
                         */
                        findOverlappingNodes: function(item, callback) {
                            if (item.x < this.x + this.w / 2) {
                                if (item.y < this.y + this.h / 2) {
                                    if (callback(TOP_LEFT)) {
                                        return true;
                                    }
                                }
                                if (item.y >= this.y + this.h / 2) {
                                    if (callback(BOTTOM_LEFT)) {
                                        return true;
                                    }
                                }
                            }
                            if (item.x >= this.x + this.w / 2) {
                                if (item.y < this.y + this.h / 2) {
                                    if (callback(TOP_RIGHT)) {
                                        return true;
                                    }
                                }
                                if (item.y >= this.y + this.h / 2) {
                                    if (callback(BOTTOM_RIGHT)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        },
                        /**
                         * @return {undefined}
                         */
                        divide: function() {
                            var childrenDepth = this.depth + 1;
                            /** @type {number} */
                            var width = this.w / 2;
                            /** @type {number} */
                            var height = this.h / 2;
                            this.nodes.push(new Node(this.x, this.y, width, height, childrenDepth));
                            this.nodes.push(new Node(this.x + width, this.y, width, height, childrenDepth));
                            this.nodes.push(new Node(this.x, this.y + height, width, height, childrenDepth));
                            this.nodes.push(new Node(this.x + width, this.y + height, width, height, childrenDepth));
                            var oldChildren = this.items;
                            /** @type {Array} */
                            this.items = [];
                            /** @type {number} */
                            var i = 0;
                            for (; i < oldChildren.length; i++) {
                                this.insert(oldChildren[i]);
                            }
                        },
                        /**
                         * @return {undefined}
                         */
                        clear: function() {
                            /** @type {number} */
                            var i = 0;
                            for (; i < this.nodes.length; i++) {
                                this.nodes[i].clear();
                            }
                            /** @type {number} */
                            this.items.length = 0;
                            /** @type {number} */
                            this.nodes.length = 0;
                        }
                    };
                    var internalSelector = {
                        x: 0,
                        y: 0,
                        w: 0,
                        h: 0
                    };
                    return {
                        root: function() {
                            return new Node(args.minX, args.minY, args.maxX - args.minX, args.maxY - args.minY, 0);
                        }(),
                        /**
                         * @param {?} item
                         * @return {undefined}
                         */
                        insert: function(item) {
                            this.root.insert(item);
                        },
                        /**
                         * @param {?} selector
                         * @param {?} callback
                         * @return {undefined}
                         */
                        retrieve: function(selector, callback) {
                            this.root.retrieve(selector, callback);
                        },
                        /**
                         * @param {number} x
                         * @param {number} y
                         * @param {number} w
                         * @param {number} h
                         * @param {?} callback
                         * @return {undefined}
                         */
                        retrieve2: function(x, y, w, h, callback) {
                            /** @type {number} */
                            internalSelector.x = x;
                            /** @type {number} */
                            internalSelector.y = y;
                            /** @type {number} */
                            internalSelector.w = w;
                            /** @type {number} */
                            internalSelector.h = h;
                            this.root.retrieve(internalSelector, callback);
                        },
                        /**
                         * @param {Object} x
                         * @return {?}
                         */
                        exists: function(x) {
                            return this.root.exists(x);
                        },
                        /**
                         * @return {undefined}
                         */
                        clear: function() {
                            this.root.clear();
                        }
                    };
                }
            };
            $(function() {
                /**
                 * @return {undefined}
                 */
                function draw() {
                    if (0 < tbOnRUDxsz.length) {
                        self.color = tbOnRUDxsz[0].color;


                        self.setName(tbOnRUDxsz[0].name);
                    }
                    c.clearRect(0, 0, 32, 32);
                    c.save();
                    c.translate(16, 16);
                    c.scale(0.4, 0.4);
                    self.draw(c);
                    c.restore();
                    ++e;
                    e %= 10;
                    if (0 == e) {

                    }
                }
                var self = new Blob(0, 0, 0, 32, "#ED1C24", "");
                /** @type {Element} */
                var canvas = document.createElement("canvas");
                /** @type {number} */
                canvas.width = 32;
                /** @type {number} */
                canvas.height = 32;
                var c = canvas.getContext("2d");
                /** @type {number} */
                var e = 0;
                draw();
                setInterval(draw, 1E3 / 60);
            });


            self.setUnlimitedZoom = function(input) {
                /** @type {boolean} */
                isUnlimitedZoom = input;
            };


	    self.spect = isSpectating;
            self.setSpectate = function(input) {
                /** @type {boolean} */
                isSpectating = input;
		
                if (isSpectating) {
			score = 0;

                } else {

                }
            };




            /** @type {function (): undefined} */
            win.onload = init;
        }
        /** @type {boolean} */
        var isShowBorders = true;
        /** @type {boolean} */
        var isUnlimitedZoom = true;
        /** @type {boolean} */
        var isInteractiveColors = true;
        /** @type {boolean} */
//        var isSpectating = false;
        /** @type {boolean} */
        var isTransparent = false;
        /** @type {boolean} */
        var isLargeNames = false;
        /** @type {boolean} */
        var isLargeBlobBorders = false;
        /** @type {boolean} */
        var isVirusTransparent = true;
        /** @type {boolean} */
        var isSimpleMode = false;
        var isHideGrid = false;
//	var isCustomBgc = false;
	var isStripSpecial = false;
	var isDisableRotation = false;
	var isBrightColors = false;
	var isArenaGameOver = false;

        var isSemiTransparentSkins = true;
	var isAlwaysShowBorders = false;
	var isAllBorders = false;

	var isCircleFood = false;
	var isGridStyle = false;
	var isHideFoodMass = false;
        /** @type {number} */
        var myMass = 0;
    }
})(window, window.jQuery);








	</script>
	<div id="base" style="display: block;"><div id="allUnder">
	<div id="white"></div>
	<div id="dark" style="display: none;"></div>
	<div class="logo"></div>
	
</div>
<div id="pre_game" style="display: none;">
	<div style="width: 680px; height: 32px;">
    </div>
    <div class="dark"></div>
    <div class="logo"></div>
    <div class="grow">
        <div class="username"><input id="paperio_p1" maxlength="12" type="text" placeholder="Your Name"></div>
        <div class="button play" style="right: 0px;" onclick="ads.show();">PLAY</div>
        <div class="loader" style="display: none"></div>
        <div class="noConnectText" style="display: none">CAN'T CONNECT TO SERVER</div>
        <div class="noConnectBtn" style="display: none" onclick="resetPage();">TRY AGAIN</div>
    </div>
</div>
<div id="game_over" style="display: block;"><div class="gameover"></div><div class="go_sc" style="display: block; margin-left: -148px;">YOUR SCORE:</div><div class="da_sc" style="display: block; zoom: 1;">5975</div><div class="go_bs" style="display: block; margin-left: -148px;"><span>NEW </span>BEST SCORE:</div><div class="da_bs" style="display: block; zoom: 1;">5975</div><div class="go_pt" style="display: block; margin-left: -148px;">TIME PLAYED:</div><div class="da_pt" style="display: block; zoom: 1;">03:31</div><div class="go_pk" style="display: block; margin-left: -148px;">BEST RATING:</div><div class="da_pk" style="display: block; zoom: 1;">9</div><div class="button share" style="width: 160px; margin-left: -208px;" onclick="window.open(&#39;https://www.facebook.com/sharer/sharer.php?u=http://paper-io.com/sharescore/5975/03:31&#39;,&#39;sharer&#39;,&#39;toolbar=0,status=0,width=580,height=325&#39;);">SHARE</div><div class="button play" style="margin-left: -28px;" onclick="Agar.tryStart();">PLAY AGAIN</div></div>
<div id="bottom"><div class="a"></div></div>
<div id="share"><div data-colorscheme="dark" class="fb-like fb_iframe_widget" data-href="https://agarpaper.io" data-layout="standard" data-action="like" data-size="large" data-show-faces="false" data-share="true" fb-xfbml-state="rendered" fb-iframe-plugin-query="action=like&amp;app_id=&amp;color_scheme=dark&amp;container_width=123&amp;href=https%3A%2F%2Fagarpaper.io%2F&amp;layout=standard&amp;locale=en_US&amp;sdk=joey&amp;share=true&amp;show_faces=false&amp;size=large"><span style="vertical-align: bottom; width: 450px; height: 28px;"><iframe name="ff1f329c91d87" width="1000px" height="1000px" data-testid="fb:like Facebook Social Plugin" title="fb:like Facebook Social Plugin" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" allow="encrypted-media" src="./AgarPaper.io_files/like.html" style="border: none; visibility: visible; width: 450px; height: 28px;" class=""></iframe></span></div><br>
<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="twitter-share-button twitter-share-button-rendered twitter-tweet-button" style="position: static; visibility: visible; width: 76px; height: 28px;" title="Twitter Tweet Button" src="./AgarPaper.io_files/tweet_button.c4b33f07650267db9f8a72eaac551cac.en.html"></iframe>
<script>
    ! function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0],
            p = /^http:/.test(d.location) ? 'http' : 'https';
        if (!d.getElementById(id)) {
            js = d.createElement(s);
            js.id = id;
            js.src = p + '://platform.twitter.com/widgets.js';
            fjs.parentNode.insertBefore(js, fjs);
        }
    }(document, 'script', 'twitter-wjs');
</script>
<script>
    (function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s);
        js.id = id;
        js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8";
        fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
</script>

</div>
<div id="links"><div id="block_links" align="right">
<a href="http://agarpaper.io/">Game</a>
<a href="http://agarpaper.io/privacy.php" target="_blank">Privacy policy</a>
<a href="http://agarpaper.io/#about" onclick="about_open(); return false;">About Game</a>
<a href="https://kevin.games/?referer=agarpaper.io" target="_blank">More Games</a>
</div></div>
<div id="dynamic_css"></div>

<style>
    #logo {
        top: 0px;
    }

    #message {
        top: 85px;
    }

    #pre_game .grow {
        top: 210px;
    }
    #game_over .button.mode {
        background: #7fed4c;
        border-bottom: 6px solid #56a130;
        color: #4f8a34;
        top: 332px;
        width: 326px;
        height: 18px;
        line-height: 20px;
        font-size: 28px;
    }
</style> </div>
	<div id="overlay"></div><div id="text"><div class="text">
  <h1>AgarPaper.io â a fresh twist on Agar.io</h1>
  <p>Agar Paper is an engaging game inspired by the beloved classic that started it all â Agar.io. Players control squares on a giant arena with a simple objective in mind: to outgrow everyone and become the biggest one on the map.</p>
  <h2>How to play Agar Paper io</h2>
  <p>There are several things to keep in mind: energy can be consumed, bombs can blow you up and squares (other players) can be engaged in battle. The bigger square always wins, so choose your battles wisely! Use your mouse cursor to steer, press the space bar to split yourself up and âWâ to attack.</p>
  <p>Agar Paper io â is meant to be played online from home, school or during commute, with friends or random players, like its predecessor â Agar.io. Itâs best to steer clear of bigger squares at first to avoid getting eaten.</p>
  <p>And hereâs the best part: it is completely free and available for every popular browser!<br> We have a dedicated pvp server that is totally private and unblocked â try it out for the ultimate Agar Paper experience!</p>
</div>
<div class="close" onclick="about_close();">Ã</div>
<script>
  function about_open() { $('#overlay,#text').fadeIn(); }
  function about_close() { $('#overlay,#text').fadeOut(); }
</script>
</div>
	

<script>
$('#allUnder').show();
$('#pre_game').show();
$(document).ready(function() { 
	//startGame('paper.io'); 
  $('#base #pre_game .button.play').css({'right':-1000}).show().animate({'right':0}, 300);
  $('#base #game_over .button.play').css({'margin-left':1118}).show().animate({'margin-left':-28}, 300);
  $('#base #game_over .button.share').css({'margin-left':-1118}).show().animate({'margin-left':-208}, 300);
  $('#base #game_over .button.mode').css({'margin-left':-1118}).show().animate({'margin-left':-158}, 300);
});



function doShowOverlay(seconds, topslot, topscore) {
	//alert('UPDATE GD BANNER');
	window.showBanner('bottom');
	Agar.showGameOver(seconds, topslot, topscore);
}

window.showBanner('bottom');


</script>

 <script src="./AgarPaper.io_files/menuApi.js"></script>
 <script src="./AgarPaper.io_files/js.cookie.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(56544403, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/56544403" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->


<iframe scrolling="no" frameborder="0" allowtransparency="true" src="./AgarPaper.io_files/widget_iframe.c4b33f07650267db9f8a72eaac551cac.html" title="Twitter settings iframe" style="display: none;"></iframe><iframe name="ym-native-frame" title="ym-native-frame" frameborder="0" aria-hidden="true" style="opacity: 0 !important; width: 0px !important; height: 0px !important; position: absolute !important; left: 100% !important; bottom: 100% !important; border: 0px !important;" src="./AgarPaper.io_files/saved_resource.html"></iframe><div id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; width: 0px; height: 0px;"><div></div></div></div></body></html>
